---
title: "Selecting data for Tender Breasts analysis"
author: "Laura Symul"
date: "11/3/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache  = FALSE)
```


```{r librairies and stuff, include = FALSE, eval = TRUE}
source("00_variables.R")
source("00_libraries.R")
source("00_functions.R")
```




```{r parameters, include=FALSE}
par = list()
par$reset = FALSE
par$N.files = 47
par$n_cores = detectCores() - 1
```


This file's code 

1. filters logs from the processed days file

  - from users that are on "none" or "condoms" or "pill" as birth control method (on-boarding data)

  - for which (category == "period") | (category == "pill_hbc") | (type == "tender_breasts")

  - also, we add rows that counts the number of logs on that day from any other category or type
  
2. defines menstruation-centered cycle ids (and add this information to the days tables)   


# Loading and filtering data

```{r birth control parameters}
par$selected_birth_control = c("none","condoms", "pill")
par$birth_control = c("none / condoms", "pill")

```


```{r loading data, eval = TRUE}

days_folder = paste0(IO$input_data,"days_selected_logs/")
if(!dir.exists(days_folder)){dir.create(days_folder)}


clue_file_list = list.files(IO$clue_data_path_days)
clue_file_list = clue_file_list[1:par$N.files]

registerDoParallel(par$n_cores)

tic()
foreach(file = clue_file_list) %dopar%
{
  cat(file,"\n")
  load(paste0(IO$clue_data_path_days, file), verbose = TRUE)
  days$cycle_id = as.character(days$cycle_id)
  # TO DO??? ONLY KEEP USERS WHOSE ALL CYCLES START WITH BLEEDING
  row.keep.bc = (days$birth_control %in% par$selected_birth_control )
  row.keep =  row.keep.bc & ( (days$category == "period") | (days$category == "pill_hbc") | (days$type == "tender_breasts") )

   # counting the number of log each day
  days$day_id = paste0(days$user_id, "_", days$date)
  days_n_logs = aggregate(type ~ day_id, days[which(row.keep.bc),], lu)
  days_n_logs$number = days_n_logs$type
  days_n_logs$type = "n_logs"
  days_n_logs$category = "n_logs"
  m = match(days_n_logs$day_id, days$day_id)
  cns = setdiff(colnames(days), colnames(days_n_logs))
  for(cn in cns){eval(parse(text = paste0("days_n_logs$",cn," = days$",cn,"[m]")))}
  rm(m, cn, cns)
  oc = match(colnames(days),colnames(days_n_logs))
  days_n_logs = days_n_logs[,oc]; rm(oc)
  
  # only keeping period, tender_breast and pill from days
  days =  days[which(row.keep), ]
  # adding the n_logs
  days = rbind(days, days_n_logs)
  # sorting days
  o = order(days$user_id, days$date)
  days = days[o,]; rm(o)
  
  # bits of pre-processing
  days$birth_control_o = factor(days$birth_control, levels = par$selected_birth_control)
  days$birth_control = as.character(days$birth_control)
  days$birth_control[days$birth_control %in% c("none","condoms")] = par$birth_control[1]
  days$birth_control = factor(days$birth_control, levels = par$birth_control)
  days$country = as.character(days$country)
  # save file
  save(days, file = paste0(days_folder,file))
  rm(row.keep, days)
}
toc()
stopImplicitCluster()
rm(clue_file_list, days_folders)


```


# Pre-processing

## Defining menstruation-centered cycle_ids and counting cycledays from menstruation

Let's consider the luteal phase to be "fixed" so that any day within D days from the next menses will belong to the next cycle.

The column "cycleday_m" counts the days from menstruation with 0 = first day of menstruation going from -D to +x with x = cycle_length - D.

The column "cycleday_m_D" counts the days from menstruation with 0 = first day of menstruation going from -D to +X with X = min(Df,cycle_length - D).

Also, the start of the first cycle and the end of the last cycles should be removed so that cycle_id_m, cycleday_m and cycleday_m_D = NA for those (as they are "incomplete menstruation-centered cycles").



```{r define menstruation-centered cycle_id - parameters}

par$Df
par$D

```


```{r define menstruation-centered cycle_id - function}

define_menstruation_centered_cycles = function(days = days, par = par){
  
  # cycle id and cycle number
  
  days$cycle_id_m = days$cycle_id
  days$cycle_nb_m = days$cycle_nb
  
  end.j = which(days$cycleday_from_end >= -par$D)
  days$cycle_id_m[end.j] = paste0(days$user_id[end.j],"_",days$cycle_nb[end.j]+1)
  days$cycle_nb_m[end.j] = days$cycle_nb[end.j]+1
  
  rm(end.j)
  
  # cycleday_m and cycleday_m_D
  
  days$cycleday_m = days$cycleday-1
  days$cycleday_m_D = NA
  
  j.start = which((days$cycle_id_m == days$cycle_id) & (days$cycleday_m <= par$Df))
  days$cycleday_m_D[j.start] = days$cycleday[j.start]-1
  
  j.end = which(days$cycle_id_m != days$cycle_id)
  days$cycleday_m[j.end] = days$cycleday_from_end[j.end]
  days$cycleday_m_D[j.end] = days$cycleday_from_end[j.end]
  
  
  rm(j.start, j.end)
  
  # ignore what is before or after the first or last FULL cycle_id_m 
  # (i.e. we set to NA the start of the first cycle of a user 
  # and the end of the last cycle of a user)
  
  agg = aggregate(cycle_nb ~ user_id, days, range)
  agg$cycle_id_m1 = paste0(agg$user_id, "_",agg$cycle_nb[,1])
  agg$cycle_id_m2 = paste0(agg$user_id, "_",agg$cycle_nb[,2]+1)
  
  m1 = match(days$cycle_id_m, agg$cycle_id_m1)
  days$cycle_id_m[!is.na(m1)] = NA
  days$cycle_nb_m[!is.na(m1)] = NA
  days$cycleday_m[!is.na(m1)] = NA
  days$cycleday_m_D[!is.na(m1)] = NA
  
  
  m2 = match(days$cycle_id_m, agg$cycle_id_m2)
  days$cycle_id_m[!is.na(m2)] = NA
  days$cycle_nb_m[!is.na(m2)] = NA
  days$cycleday_m[!is.na(m2)] = NA
  days$cycleday_m_D[!is.na(m2)] = NA
  
  rm(agg, m1, m2)
  
  return(days)

}


```



```{r define menstruation-centered cycle_id, eval = TRUE}

input_folder = paste0(IO$Rdata,"days_selected_logs/")

output_folder = paste0(IO$Rdata,"days_with_menstruation_centered_cycles/")
if(!dir.exists(output_folder)){dir.create(output_folder)}

clue_file_list = list.files(input_folder)
clue_file_list = clue_file_list[1:par$N.files]

registerDoParallel(par$n_cores)

tic()
foreach(file = clue_file_list) %dopar%
{
  cat(file,"\n")
  load(paste0(input_folder,file), verbose = TRUE)
  cat(dim(days),"\n")
  days  = define_menstruation_centered_cycles(days = days, par = par)
  cat(dim(days),"\n")
  save(days, file = paste0(output_folder,file))
  rm(days)
}
toc()
stopImplicitCluster()
rm(file, clue_file_list, input_folder, output_folder )

```



## DEPRECATED (Not evaluated) Defining cycle start as 1st day of heaviest bleeding from the first stretch of continuous bleeding

```{r cycle start as 1st day of heaviest bleeding - function, eval = FALSE}

define_cycle_start_with_heaviest_bleeding = function(days = days, par = par){
  
  # first, find the first day of heaviest bleeding
  days$number[days$type == "heavy"] = 3
  days$number[days$type == "medium"] = 2
  days$number[days$type == "light"] = 1
  days$number[days$type == "spotting"] = 0.5
  
  
  agg_max_b = aggregate(number ~ cycle_id, days[(days$category == "period") & (days$cycleday <= (2*days$period_length)),], max)
  max_b = agg_max_b$number[match(days$cycle_id, agg_max_b$cycle_id)]
  
  agg_first_b = aggregate(cycleday ~ cycle_id, days[days$number == max_b,], min)
  first_max_b = agg_first_b$cycleday[match(days$cycle_id, agg_max_b$cycle_id)]
  
  days$cycleday_max_b = days$cycleday - first_max_b
  
  rm(max_b,first_max_b, agg_max_b, agg_first_b)
  
  # then we define cycle nb, id, cycleday and cycleday_from_end for these newly defined cycles
  
  
  days$cycle_nb_max_b = days$cycle_nb - 1 * (days$cycleday_max_b < 0)
  days$cycle_id_max_b = paste0(days$user_id,"_", days$cycle_nb_max_b)
  
  
  agg_cycles = days[days$cycleday_max_b == 0,c("user_id","cycle_id_max_b","cycle_nb_max_b","date")]
  agg_cycles$next_cycle_nb = agg_cycles$cycle_nb_max_b + 1
  agg_cycles$next_cycle_id = paste0(agg_cycles$user_id,"_",agg_cycles$next_cycle_nb)
  agg_cycles$cycle_start_max_b = agg_cycles$date
  agg_cycles$cycle_end_max_b = agg_cycles$cycle_start_max_b[match(agg_cycles$next_cycle_id, agg_cycles$cycle_id_max_b)]-1
  
  m = match(days$cycle_id_max_b, agg_cycles$cycle_id_max_b)
  days$cycle_start_max_b =agg_cycles$cycle_start_max_b[m]
  days$cycle_end_max_b =agg_cycles$cycle_end_max_b[m]
  days$cycle_end_max_b[is.na(days$cycle_end_max_b)] = days$cycle_end[is.na(days$cycle_end_max_b)]
  
  days$cycle_length_max_b = as.numeric(days$cycle_end_max_b - days$cycle_start_max_b + 1) 
  
  days$cycleday_max_b = as.numeric(days$date - days$cycle_start_max_b)
  days$cycleday_from_end_max_b = as.numeric( days$date -  days$cycle_end_max_b  - 1)
  
  # finally, we define menstruation-centered cycles where start of menstruation is first day of heaviest bleeding
  #cycle_id and cycle_nb
  
  days$cycle_id_mb = days$cycle_id_max_b
  days$cycle_nb_mb = days$cycle_nb_max_b
  
  end.j = which(days$cycleday_from_end_max_b >= -par$D)
  days$cycle_nb_mb[end.j] = days$cycle_nb_max_b[end.j]+1
  days$cycle_id_mb[end.j] = paste0(days$user_id[end.j],"_",days$cycle_nb_mb[end.j])
  
  rm(end.j)
  
  #cycleday_mb and cycleday_mb_D
  
  days$cycleday_mb = days$cycleday_max_b
  days$cycleday_mb_D = NA
  
  j.start = which((days$cycle_id_mb == days$cycle_id_max_b) & (days$cycleday_mb <= par$Df))
  days$cycleday_mb_D[j.start] = days$cycleday_max_b[j.start]
  
  j.end = which(days$cycle_id_mb != days$cycle_id_max_b)
  days$cycleday_mb[j.end] = days$cycleday_from_end_max_b[j.end]
  days$cycleday_mb_D[j.end] = days$cycleday_from_end_max_b[j.end]
  
  rm(j.start, j.end)
  
  # removing the very start and very end of each user tracking 
  
  agg = aggregate(cycle_nb_max_b ~ user_id, days, range)
  agg$cycle_id_m1 = paste0(agg$user_id, "_",agg$cycle_nb_max_b[,1])
  agg$cycle_id_m2 = paste0(agg$user_id, "_",agg$cycle_nb_max_b[,2]+1)
  
  m1 = match(days$cycle_id_mb, agg$cycle_id_m1)
  days$cycle_id_mb[!is.na(m1)] = NA
  days$cycle_nb_mb[!is.na(m1)] = NA
  days$cycleday_mb[!is.na(m1)] = NA
  days$cycleday_mb_D[!is.na(m1)] = NA
  
  
  m2 = match(days$cycle_id_mb, agg$cycle_id_m2)
  days$cycle_id_mb[!is.na(m2)] = NA
  days$cycle_nb_mb[!is.na(m2)] = NA
  days$cycleday_mb[!is.na(m2)] = NA
  days$cycleday_mb_D[!is.na(m2)] = NA
  
  rm(agg, m1, m2)
  
  
  j = grep("max_b",colnames(days))
  if(length(j)>0){days = days[,-j]}
  
  return(days)
  
}

```





```{r cycle start as 1st day of heaviest bleeding - and saving processed days files, eval = FALSE}

input_folder = paste0(IO$Rdata,"days_with_menstruation_centered_cycles/")

output_folder = paste0(IO$Rdata,"days/")
if(!dir.exists(output_folder)){dir.create(output_folder)}

clue_file_list = list.files(input_folder)
clue_file_list = clue_file_list[1:par$N.files]

registerDoParallel(par$n_cores)
tic()
foreach(file = clue_file_list) %dopar%
{
  cat(file,"\n")
  load(paste0(input_folder,file), verbose = TRUE)
  cat(dim(days),"\n")
  days  = define_cycle_start_with_heaviest_bleeding(days = days, par = par)
  cat(dim(days),"\n")
  save(days, file = paste0(output_folder,file))
  rm(days)
}
toc()
stopImplicitCluster()
rm(clue_file_list, input_folder, output_folder )

```





# Cycles and users tables update

Now we need to update the cycles and users table to only keep the cycles and users from users that are in the days tables


```{r load cycles and users, eval = TRUE}

load(paste0(IO$clue_data_path,"cycles.Rdata"), verbose = TRUE)
load(paste0(IO$clue_data_path,"users.Rdata"), verbose = TRUE)

```



```{r filter cycles and users based on user_ids, eval = TRUE}

input_folder = paste0(IO$input_data,"days/")
output_folder = IO$input_data

clue_file_list = list.files(input_folder)
clue_file_list = clue_file_list[1:par$N.files]

registerDoParallel(par$n_cores)
tic()
users_from_days = foreach(file = clue_file_list, .combine = rbind) %dopar%{
  cat(file,"\n")
  load(paste0(input_folder,file), verbose = TRUE)
  days$n_tender_breasts = as.numeric(days$type == "tender_breasts")
  days$n_pill = as.numeric(days$category == "pill_hbc")
  this_users_from_days =  aggregate(days[,c("n_tender_breasts","n_pill")], by = list(user_id = days$user_id), FUN = sum)
  rm(days)
  return(this_users_from_days)
}
toc()
stopImplicitCluster()


cycles_keep = cycles$user_id %in% users_from_days$user_id
users_keep = users$user_id %in% users_from_days$user_id

sum(cycles_keep)/nrow(cycles)
sum(users_keep)/nrow(users)

cycles = cycles[cycles_keep,]
users = users[users_keep,]
users = merge(users, users_from_days, by = "user_id", all = TRUE)

cycles$birth_control_o = factor(cycles$birth_control, levels = par$selected_birth_control)
cycles$birth_control[cycles$birth_control %in% c("none","condoms")] = par$birth_control[1]
cycles$birth_control = factor(cycles$birth_control, levels = par$birth_control)

users$birth_control_o = factor(users$birth_control, levels = par$selected_birth_control)
users$birth_control[users$birth_control %in% c("none","condoms")] = par$birth_control[1]
users$birth_control = factor(users$birth_control, levels = par$birth_control)



save(cycles, file = paste0(output_folder, "cycles.Rdata"))
save(users, file = paste0(output_folder, "users.Rdata"))

rm(clue_file_list, input_folder, output_folder, cycles_keep, users_keep, cycles, users, users_from_days )
```




```{r clear workspace}
rm(list=ls())
```




# Cycles table update with n_days_obs at start and end of cycles.

```{r add n_logs at start and end of cycles}

load(file = paste0(IO$input_data, "cycles.Rdata"), verbose = TRUE)
dim(cycles)

input_folder = paste0(IO$input_data,"days/")
clue_file_list = list.files(input_folder)
clue_file_list = clue_file_list[1:par$N.files]

registerDoParallel(par$n_cores)
tic()
n_logs_start_end = foreach(file = clue_file_list, .combine = rbind) %dopar%{
  cat(file,"\n")
  load(paste0(input_folder,file), verbose = TRUE)

  end = aggregate(cycleday_m_D ~ cycle_id, days[days$cycleday_m_D %in% -par$D:-1,], uniqueN)
  colnames(end) = c("cycle_id","n_days_obs_end")
 
  start = aggregate(cycleday_m_D ~ cycle_id, days[days$cycleday_m_D %in% 0:par$Df,], uniqueN)
  colnames(start) = c("cycle_id","n_days_obs_start")

  this_n_logs_start_end = merge(end, start, by =  "cycle_id", all = TRUE)
  rm(days)
  return(this_n_logs_start_end)
}
toc()
stopImplicitCluster()

save(n_logs_start_end, file = paste0(IO$tmp_Rdata,"tmp_n_logs_start_end.Rdata"))

```

```{r save this info in cycles}

load(file = paste0(IO$input_data,"cycles_no_BC.Rdata"), verbose = TRUE)

m = match(cycles$cycle_id, n_logs_start_end$cycle_id)
cycles$n_days_obs_end = n_logs_start_end$n_days_obs_end[m]
cycles$n_days_obs_start = n_logs_start_end$n_days_obs_start[m]
cycles$n_days_obs_end[is.na(cycles$n_days_obs_end)] = 0
cycles$n_days_obs_start[is.na(cycles$n_days_obs_start)] = 0

save(cycles, file = paste0(IO$input_data,"cycles_no_BC.Rdata"))

rm(m, n_logs_start_end)
```



