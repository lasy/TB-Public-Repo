---
title: "tmp copy paste"
author: "Laura Symul"
date: "4/15/2019"
output: html_document
---



```{r child = '_cycle_clustering.Rmd', cache=TRUE}
```


```{r child = '_pill_transition_analysis.Rmd', cache=TRUE}
```



######################



```{r child = '_cycle_clust_optimal_cluster_number.Rmd', cache=TRUE}
```


```{r child = '_cycle_clust_clustering.Rmd', cache=TRUE}
```


```{r child = '_cycle_clust_users_descr_cluster_info.Rmd', cache=TRUE}
```



######################






## Selecting consistent and inconsistent users


```{r users_descr_examples selecting consistent and inconsistent users from each TB cluster}

N = max(users$most_preval_clust, na.rm = TRUE)
N_users = 5 

consistent_users = data.frame()
inconsistent_users = data.frame()


for(n in 1:N){
  j = which(
    (users$most_preval_clust == n) & 
      (users$batch == 1) & 
      (users$n_cycles_m %in% 7:10) & 
      (users$perc_cycles_with_TB > 0.7))
  sub_users = users[j,]
  
  o = order(sub_users$median_d, decreasing = FALSE)
  sub_users[o[1],]
  
  N_users_n = min(N_users, ceiling(nrow(sub_users)/2))
  if(N_users_n >= 1){
    consistent_users = rbind(consistent_users, sub_users[o[1:N_users_n],])
    inconsistent_users = rbind(inconsistent_users, sub_users[o[(length(o)-N_users_n+1) : length(o)],])
  }
}

consistent_users$consistent = TRUE
inconsistent_users$consistent = FALSE

selected_users = rbind(consistent_users, inconsistent_users)

```




```{r users_descr_examples showing the examples of consistent and inconsistent users from each TB cluster, fig.height=12, fig.width=12}


load(paste0(IO$tmp_data,"avg_dist_per_user/d_1.Rdata"), verbose = TRUE)

m = match(d$user_id, selected_users$user_id)
d$consistent = selected_users$consistent[m]
d$most_preval_cluster = selected_users$most_preval_clust[m]
d$cluster_num = cycles_m$cluster_num[match(d$cycle_id_m, cycles_m$cycle_id_m)]

sel_d = d[d$user_id %in% selected_users$user_id,]

sel_d = melt(sel_d, id.vars = c("user_id","cycle_id_m","consistent","most_preval_cluster","cluster_num"))

sel_d$cycleday_m_D = as.numeric(gsub("\\.","-",gsub("n\\.","",sel_d$variable)))
sel_d$cycle_nb_m = unlist(strsplit(as.character(sel_d$cycle_id_m), "_"))[(1:nrow(sel_d))*2]
sel_d$tender_breasts = sel_d$value

sel_d = sel_d[,c("user_id","cycle_nb_m","cycleday_m_D","tender_breasts","consistent","most_preval_cluster","cluster_num")]

sel_d_consistent = sel_d[sel_d$consistent, ]
sel_d_inconsistent = sel_d[!sel_d$consistent, ]

if(nrow(sel_d_inconsistent)>0){
  
  g_consistent = ggplot_imputed_TB(sel_d = sel_d_consistent, 
                                   facet_grid = c("most_preval_cluster","user_id"), cycle_id = FALSE, col = "cluster_num")#+
  #scale_color_manual(values = cols$clusters_6)
  
  
  g_inconsistent = ggplot_imputed_TB(sel_d = sel_d_inconsistent, 
                                     facet_grid = c("most_preval_cluster","user_id"), cycle_id = FALSE, col = "cluster_num")#+
  #scale_color_manual(values = cols$clusters_6)
  
  grid.arrange(g_consistent, g_inconsistent, nrow = 1)
  
}else{
  
  g_consistent = ggplot_imputed_TB(sel_d = sel_d_consistent, 
                                   facet_grid = c("most_preval_cluster","user_id"), cycle_id = FALSE, col = "cluster_num")#+
  #scale_color_manual(values = cols$clusters_6)
  g_consistent
}

```




```{r clust_tracking_behavior optimal number of clusters - deprecated, fig.width= 10, fig.height= 4, eval = FALSE}

n_cluster_range = 2:10
df = data.frame()


for(n_clust in n_cluster_range){
  cat(n_clust,"\n")
  tracking_clustering = clara(x = X, 
                              k = n_clust, 
                              metric = "euclidean",
                              samples = 50,
                              sampsize = 200)
  cat("\t\t",tracking_clustering$silinfo$avg.width,"\n")
  df = rbind(df,data.frame(n_clust = n_clust, avg_silhouette_score = tracking_clustering$silinfo$avg.width))
  
  silh = as.data.frame(tracking_clustering$silinfo$widths)
  silh$x = 1:nrow(silh)
  silh$rows = as.numeric(rownames(tracking_clustering$silinfo$widths))
  
  X_long$cluster_num = tracking_clustering$clustering[match(X_long$rows, X_wide$rows)]
  
  # show the samples chosen by clara FOR SILHOUETTE
  
  m = which(!is.na(match( X_long$rows, silh$rows)))
  X_long_subset = X_long[m,]
  X_long_subset$rows = factor(X_long_subset$rows, levels = rev(silh$rows))
  g_samples = ggplot(X_long_subset,aes(x = variable, y = rows, col = value))+ geom_point() + 
    guides(color = FALSE) + scale_color_gradient(low = "white",high = "blue4")+ggtitle(paste("n_clust = ",n_clust))
  
  g_silh = ggplot(silh, aes(fill = factor(cluster),x = factor(x, levels =rev(x)), y = sil_width)) + coord_flip()+
    geom_bar(stat = "identity")+
    #ylim(c(-1,1))+
    geom_hline(yintercept = tracking_clustering$silinfo$avg.width, linetype = 2)+ 
    ggtitle(paste0("avg. silh score = ",round(tracking_clustering$silinfo$avg.width,digits = 3)))+
    guides(fill = FALSE, color = FALSE)+
    xlab("")+ylab("silh width")+ theme(axis.text.y = element_blank())
  
  grid.arrange(g_samples, g_silh, nrow = 1, widths = c(2,1))
  
}

ggplot(df, aes(x = factor(n_clust), y = avg_silhouette_score)) + geom_bar(stat = "identity")

```








######################


```{r user_filt create tmp tracking dir}

raw_batches_folder = paste0(IO$tmp_data,"tracking_raw_batches/")
dir.create(raw_batches_folder)

days_output = paste0(IO$output_data,"days/")
dir.create(days_output)

```


```{r user_filt filtering days}

tracking_folder = paste0(IO$input_data,"tracking_filtered/")
filenames = list.files(tracking_folder)

cl = makeCluster(par$n_cores)
registerDoParallel(cl)

tic()
users_original_files = foreach(filename = filenames, .combine = rbind) %dopar% 
{
  load(paste0(tracking_folder, filename), verbose = TRUE)
  original_file_id = substr(filename,25,26)
  j = which(tracking$user_id %in% users$user_id)
  tracking = tracking[j,]
  tracking$batch =  users$batch[match(tracking$user_id, users$user_id)]
  for(b in unique(tracking$batch)){
    days = tracking[which(tracking$batch == b),]
    save(days, file = paste0(raw_batches_folder,"days_", original_file_id,"_batch_",b,".Rdata"))
  }
  users_original_file = data.frame(user_id = unique(tracking$user_id), original_file_id = original_file_id)
  return(users_original_file)
}
toc()
stopImplicitCluster()

save(users_original_files, file = paste0(IO$tmp_data, "users_original_files.Rdata"))


```

```{r user_filt saving the original file ids}

users_o_f = aggregate(original_file_id ~ user_id ,users_original_files, paste0, collapse = ",")
users$original_files = users_o_f$original_file_id[match(users$user_id, users_o_f$user_id)]

save(users, file = paste0(IO$output_data,"users.Rdata"))
file.copy(paste0(IO$output_data,"users.Rdata"), paste0(IO$tmp_data,"users_after_filtering_days.Rdata"), overwrite = TRUE)

```




```{r user_filt re-assembling batches, eval = FALSE}

filenames = list.files(raw_batches_folder)

cl = makeCluster(par$n_cores)
registerDoParallel(cl)

foreach(b = unique(users$batch)) %dopar% {
  cat(b,"\n")
  j = grep(paste0("_batch_",b,".Rdata"), filenames)
  j
  filenames[j]
  DAYS = data.frame()
  for(i in j){
    cat("\t",i,"\n")
    load(paste0(raw_batches_folder,filenames[i]), verbose = TRUE)
    DAYS = rbind(DAYS, days)
  }
  days = DAYS
  rm(DAYS)
  dim(days)
  save(days, file = paste0(days_output, "days_",b,".Rdata"))
  
}

stopImplicitCluster()
```

```{r microbenchmark}

library(tidyverse)
library(sqldf)
library(microbenchmark)

# Generate an example dataset with two numeric columns and 5 million rows
data_frame(
  norm = rnorm(5e6, mean = 5000, sd = 1000),
  unif = runif(5e6, min = 0, max = 10000)
) %>%
write_csv('medium.csv')

microbenchmark(
  read_csv  = read_csv("medium.csv",col_types = 'dd',  progress = F ),
  read.csv  = read.csv("medium.csv",stringsAsFactors = FALSE),
  times  = 10L
)

tic()
read_csv  = read_csv("medium.csv", progress = F )
toc()


tic()
read.csv  = read.csv("medium.csv",stringsAsFactors = FALSE)
toc()

```



```{r data_prep_BC_re_class test glm only on cycle length}

sample_size = 100000

j_pill =  which(cycles$birth_control_CLUE == "pill")
j_pill = sample(j_pill, min(length(j_pill),round(sample_size/2)))
j_nc =  which(cycles$birth_control_CLUE == "none / condoms")
j_nc = sample(j_nc, min(length(j_nc),round(sample_size/2)))

j = c(j_pill, j_nc)
cycles_training_set = cycles[j , ]
cycles_training_set$birth_control_CLUE = factor(as.character(cycles_training_set$birth_control_CLUE), levels = c("pill", "none / condoms"))


glm_cl = glm(birth_control_CLUE ~ cycle_length, data = cycles_training_set, family = "binomial")
summary(glm_cl)

new_data = data.frame(cycle_length = -1000:1000)

prob = predict(glm_cl, newdata = new_data, type = "response")

plot(prob)
abline(h = 0.5)



glm_cl_score = glm(birth_control_CLUE ~ cycle_length_score + cycle_length, data = cycles_training_set, family = "binomial")
summary(glm_cl_score)

new_data = cycles[1:10000,]

prob = predict(glm_cl_score, newdata = new_data, type = "response")

plot(new_data$cycle_length_score, prob, pch = 16, cex = 0.5)
abline(h = 0.5)

plot(new_data$cycle_length, prob, pch = 16, cex = 0.5)
abline(h = 0.5)

```



### Classifying cycles using a SVM


```{r data_prep_BC_re_class svm training subset size}
subset_perc = 1
sample_size = round(subset_perc*nrow(cycles)/100)
min_sample_size = 1000
sample_size = max(sample_size, min(nrow(cycles),min_sample_size))
sample_size
```

We will only use a subset (`r subset_perc`% or at least `r min_sample_size` cycles) of the data to train the model.

This represents `r sample_size` cycles, selected randomly.

And we only train on cycles of users that indicated `pill`, `none` or `condoms` and exclude users that `did not enter` their birth control in the settings

```{r data_prep_BC_re_class svm training, warning=FALSE}
j =  which(cycles$birth_control_CLUE %in% c("pill", "none / condoms"))
j = sample(j, min(length(j),sample_size))
cycles_training_set = cycles[j , ]
cycles_training_set$birth_control_CLUE = factor(as.character(cycles_training_set$birth_control_CLUE), levels = c("pill", "none / condoms"))

# fit
tic()
eval(parse(text = paste0("svm_fit = alphasvm(birth_control_CLUE ~ ",paste(inputs, collapse = " + "),", 
                         data = cycles_training_set , 
                         probability = TRUE)")))
tac(chunck_name = "data_prep_BC_re_class svm training")
summary(svm_fit)
save(svm_fit, file = paste0(IO$tmp_data, "svm_fit.Rdata"))
```

The SVM training scales as $O(n^2)$.





```{r data_prep_BC_re_class svm predictions, warning=FALSE}

# prediction
cycles$SVM_prob = NA
j = 1:nrow(cycles)
#j = which(cycles$user_id %in% unique(cycles$user_id)[1:1000])

tic()
SVM_prob = predict(svm_fit, newdata = cycles[j,inputs], decision.value = TRUE, probability = TRUE)
tac(chunck_name = "data_prep_BC_re_class svm predictions")
SVM_prob_p = attr(SVM_prob, "probabilities")
head(SVM_prob_p, 20)

cycles$SVM_prob[j] = SVM_prob_p[,which(colnames(SVM_prob_p) == "pill")]

```
The SVM prediction scales as $O(n)$.


```{r data_prep_BC_re_class save svm}
save(cycles, file = paste0(IO$tmp_data, "cycles_SVM.Rdata"))
```


```{r data_prep_BC_re_class checks, fig.height=10, fig.width=7 }

load(paste0(IO$tmp_data,"cycles_glm.Rdata"), verbose = TRUE)
colnames(cycles)


ggplot(cycles[sample(1:nrow(cycles),10000),], aes(x = SVM_prob, y = glm_prob, col = birth_control_CLUE))+
  geom_point(alpha = 0.3)

ggplot(cycles, aes(x = SVM_prob,fill = birth_control_CLUE))+
  geom_histogram(position ="identity", binwidth = 0.01)+facet_grid(birth_control_CLUE~.)

ggplot(cycles, aes(x = glm_prob,fill = birth_control_CLUE))+
  geom_histogram(position ="identity", binwidth = 0.01)+facet_grid(birth_control_CLUE~.)


by = 0.001
h_pill = hist(cycles$prob[(cycles$birth_control_CLUE == "pill")], breaks = seq(0-by/2,1+by/2,by = by), plot = TRUE)
h_nc = hist(cycles$prob[(cycles$birth_control_CLUE != "pill")], breaks = seq(0-by/2,1+by/2,by = by), plot = TRUE)

h_pill = data.frame(mids = h_pill$mids, density = h_pill$density*by)
h_nc = data.frame(mids = h_nc$mids, density = h_nc$density*by)

h_pill$density_corrected = h_pill$density * 1 
h_nc$density_corrected = h_nc$density * 1


g_pill = ggplot(h_pill, aes(x = mids, y = density) )+ 
  geom_line(col = "blue")+
  geom_line(aes(y = density_corrected), col = "red") + 
  xlab("prob") + ylab("density")+
  ggtitle("pill prob density")

g_nc = ggplot(h_nc, aes(x = mids, y = density) )+ 
  geom_line(col = "blue")+
  geom_line(aes(y = density_corrected), col = "red") + 
  xlab("prob") + ylab("density")+
  ggtitle("none/condoms prob density")

grid.arrange(g_pill, g_nc)


sub_cycles = cycles[cycles$user_id %in% unique(cycles$user_id)[1:80],]
sub_cycles$user_id_n = factor(sub_cycles$user_id_n, levels = unique(sub_cycles$user_id_n[order(sub_cycles$birth_control_CLUE)]))

g_svm = ggplot(sub_cycles, aes(x = cycle_nb, y = user_id_n, col = SVM_prob)) + geom_point() + facet_grid(birth_control_CLUE ~ ., scale = "free_y")+ scale_color_gradient2(low = cols$NC, high = cols$pill, mid = "gray90", midpoint = 0.5)+theme(legend.position="right")

grid.arrange(g_svm, nrow = 1)

rm(sub_cycles,g_svm)


sub_cycles = cycles[cycles$user_id %in% unique(cycles$user_id)[1:80],]
sub_cycles$user_id_n = factor(sub_cycles$user_id_n, levels = unique(sub_cycles$user_id_n[order(sub_cycles$birth_control_CLUE)]))

g_glm = ggplot(sub_cycles, aes(x = cycle_nb, y = user_id_n, col = glm_prob)) + geom_point() + facet_grid(birth_control_CLUE ~ ., scale = "free_y")+ scale_color_gradient2(low = cols$NC, high = cols$pill, mid = "gray90", midpoint = 0.5)+theme(legend.position="right")

grid.arrange(g_glm, nrow = 1)

rm(sub_cycles,g_glm)





```




```{r data_prep_BC_re_class generating synthetic data, eval = FALSE, include = FALSE}

BC = c("none / condoms","pill","did not enter")
input_to_generate = inputs[- which(inputs %in% c("diff_cl_median_3c","cl_sd_3c", "cycle_start"))]

n_users = 30

s_users = data.frame(
  user_id = sprintf("u%03d", 1:n_users),
  n_cycles = rpois(n_users, 10), 
  birth_control_CLUE = sample(BC,n_users, replace = TRUE))

s_cycles = data.frame(user_id = rep(s_users$user_id, s_users$n_cycles))
s_cycles$cycle_nb = foreach(nc = s_users$n_cycles, .combine = c) %do% {1:nc}
s_cycles$cycle_id = paste0(s_cycles$user_id,"_",s_cycles$cycle_nb)
s_cycles$birth_control_CLUE = s_users$birth_control_CLUE[match(s_cycles$user_id, s_users$user_id)]


# generate "true birth control" 
s_cycles$true_BC = ""

for(u in s_users$user_id){
  transProbs = matrix(c(hmm$p_stay_in_same,1-hmm$p_stay_in_same,1-hmm$p_stay_in_same,hmm$p_stay_in_same),2,2)
  start_prob_nc = c(0.8,0.2,0.6)[as.numeric(factor(s_users$birth_control_CLUE[1],levels = BC))]
  
  hmm_mod_sim = initHMM(
  States =  hmm$bc_states[1:2], Symbols =  seq(0,1,by = 0.1), 
  startProbs =  c(start_prob_nc,1-start_prob_nc), transProbs =  transProbs, 
  emissionProbs =  hmm$bc_emission_prob[1:2,1:11])

  rm(transProbs)  
  
  true_BC = simHMM(hmm_mod_sim, length = s_users$n_cycles[s_users$user_id == u])
  s_cycles$true_BC[s_cycles$user_id == u] = true_BC$states
}

# now generating the input variables

# first empty columns
for(input in input_to_generate){
  eval(parse(text = paste0("s_cycles$",input,"= NA")))
}
s_cycles$true_BC_prob = NA

# then the data
for(i in 1:nrow(s_cycles)){
  s_cycles$true_BC_prob[i] = round(sample(cycles$prob[cycles$BC == s_cycles$true_BC[i]],1),2)
  j = which((round(cycles$prob,2) ==  s_cycles$true_BC_prob[i]) & (cycles$BC == s_cycles$true_BC[i]))
  for(input in input_to_generate){
    eval(parse(text = paste0("s_cycles$",input,"[i]= sample(cycles$",input,"[j],1)")))
  }
}




```





```{r data_prep_BC_re_class visualization of generated input variables, eval = FALSE, include = FALSE}

for(input in input_to_generate){
  eval(parse(text = paste0("s_cycles$v = s_cycles$",input)))
  
  g1 =  ggplot(s_cycles, aes(x = v, col = birth_control_CLUE)) + geom_freqpoly(aes(y = ..density..),binwidth = 1) +
    ggtitle(input) +
    scale_color_manual(values = c(cols$BC,"gray")) + 
    xlim(quantile(cycles$v,p = c(0.005,0.955), na.rm = TRUE)+c(-1,1))

  
  g2 =  ggplot(s_cycles, aes(x = v, col = true_BC)) + geom_freqpoly(aes(y = ..density..),binwidth = 1) +
    ggtitle(input) +
    scale_color_manual(values = c(cols$BC,"gray")) + 
    xlim(quantile(cycles$v,p = c(0.005,0.955), na.rm = TRUE)+c(-1,1))
  
  print(grid.arrange(g1,g2))
  
}

j = which(colnames(s_cycles)=="v")
if(length(j)>0){s_cycles = s_cycles[,-j]}
```



```{r data_prep_BC_re_class saving generated input variables, eval = FALSE, include = FALSE}

save(s_cycles, file = paste0(IO$tmp_data, "generated_cycles.Rdata"))

```



```{r}
head(cycles[(cycles$user_id_n == 78),c("user_id_n","cycle_nb","prob","conf","BC_hmm_init", "ok","longest_stretch")], 200)

```





```{r}
load("../../TB-Restricted-Access-Repo/stuff_from_sherlock/cycles_BC_re_classification_final.Rdata", verbose = TRUE)
cycles_full = cycles
cycles = cycles_full[which(cycles_full$user_id_n %in% unique(cycles_full$user_id_n)[1:6000]),]

cycles_sherlock = cycles

plot(cycles$prob, cycles_sherlock$prob, pch = 16, cex = 0.1)
max(abs(cycles$prob- cycles_sherlock$prob))

cont_table = table(cycles$BC_hmm_init, cycles_sherlock$BC_hmm_init)
round(cont_table/apply(cont_table,1,sum)*100, 2)


cycles_sherlock[cycles_sherlock$user_id_n == 78, c("user_id","cycle_nb","prob","BC_hmm_init")]
cycles[cycles$user_id_n == 78, c("user_id","cycle_nb","prob","BC_hmm_init")]



```

### Adding memory with an HMM

![](../Figures Tables Media/Media/cycle_classification_hmm_states_4 states HMM.png)

Model initialisation:


```{r data_prep_BC_re_class hmm: model initialization}
hmm = list()

# defining model
hmm$bc_states = c("none / condoms","pill","X-nc", "X-pill","X-did-not-enter") # we split the state X into 3 sub-states to account for the on-boarding BC info of a given user
hmm$symbols = c(paste0("p_",0:10),"X-nc","X-pill","X-did-not-enter")

#initializing model

bc_emission_prob.N = c(dbeta(seq(0,1,by = 0.1), shape1 = 1 , shape2 = 3)+0.2,0,0,0) # more likely to observe LOW score for N/C
bc_emission_prob.P = c(dbeta(seq(0,1,by = 0.1), shape1 = 3 , shape2 = 1)+0.2,0,0,0) # more likely to observe HIGH score for pill
bc_emission_prob.Xnc = c(rep(0,11),1,0,0) # we only observe Xs when we switch users
bc_emission_prob.Xpill = c(rep(0,11),0,1,0) # we only observe Xs when we switch users
bc_emission_prob.Xdne = c(rep(0,11),0,0,1) # we only observe Xs when we switch users

plot(seq(0,1,by = 0.1) , bc_emission_prob.N[1:11], type = "l", col = cols$NC, lwd = 2)
points(seq(0,1,by = 0.1) , bc_emission_prob.P[1:11], type = "l", col = cols$pill, lwd = 2)


# building and normalizing emission prob matrix
hmm$bc_emission_prob = matrix(c(bc_emission_prob.N,bc_emission_prob.P, bc_emission_prob.Xnc, bc_emission_prob.Xpill,bc_emission_prob.Xdne),nrow = length(hmm$bc_states), ncol = length(hmm$symbols), byrow = TRUE)
hmm$bc_emission_prob = hmm$bc_emission_prob/apply(hmm$bc_emission_prob, 1, sum)

rm(bc_emission_prob.N,bc_emission_prob.P,bc_emission_prob.Xnc, bc_emission_prob.Xpill)


hmm$start_prob_declared = 0.6  #probability to start in the declared BC
hmm$p_stay_in_same = 0.90 # probability to stay in the same BC
hmm$p_exit = 0.01 # probability to switch to one of the X- states
hmm$bc_transition_prob = matrix(
  c( hmm$p_stay_in_same , 1 - hmm$p_stay_in_same- 3*hmm$p_exit , rep(hmm$p_exit,3),
     1 - hmm$p_stay_in_same - 3*hmm$p_exit , hmm$p_stay_in_same, rep(hmm$p_exit,3),
     hmm$start_prob_declared, 1-hmm$start_prob_declared,0,0,0,
     1-hmm$start_prob_declared, hmm$start_prob_declared,0,0,0,
     0.5, 0.5, 0,0,0), 
  nrow = length(hmm$bc_states), ncol = length(hmm$bc_states), byrow = TRUE)

hmm$start_prob = c(hmm$start_prob_declared,1-hmm$start_prob_declared, 0.5)[as.numeric(cycles$birth_control_CLUE[1])]
hmm$start_prob = c(hmm$start_prob, 1 - hmm$start_prob, 0,0,0)

hmm_mod = initHMM(
  States =  hmm$bc_states, Symbols =  hmm$symbols, 
  startProbs =  hmm$start_prob, transProbs =  hmm$bc_transition_prob, 
  emissionProbs =  hmm$bc_emission_prob)

```



Observations:

```{r data_prep_BC_re_class hmm with fit - observations are probabilities}

obs_p =  paste0("p_",round(10*cycles$prob))

# inserting Xs
x = which(diff(cycles$user_id_n) !=0) 
obs_x = c("X-nc","X-pill","X-did-not-enter")[as.numeric(cycles$birth_control_CLUE)]
id = c(seq_along(obs_p)*10, 10*x+5)
o = order(id)
obs = c(obs_p, obs_x)[o]

rm(x, id, o, obs_p, obs_x)

```



Estimating most likely BC for each cycle using the Viterbi algorithm:




```{r data_prep_BC_re_class viterbi on init model}
# running viterbi
tic()
vit_init = viterbi(hmm = hmm_mod, obs = obs) 
tac(chunck_name = "data_prep_BC_re_class viterbi on init model")

vit_init_no_x = vit_init[-grep("X-",vit_init)]
cycles$BC_hmm_init = vit_init_no_x

rm(vit_init, vit_init_no_x, hmm_mod, obs)
```
