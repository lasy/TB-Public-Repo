---
title: "Defining the clustering metric"
author: "Laura Symul"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2: 
    theme: flatly
    highlight: haddock
    toc: yes
    toc_float: true
    toc_depth: 5
    number_sections: true
    fig_caption: true
---



```{r cycle_clust_metric librairies and stuff, include = FALSE, eval = TRUE}
source("Scripts/00_setup.R")
```


```{r cycle_clust_metric setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
options(scipen=999)
```


## Defining clustering metric

We want to define a metric that allows for the comparison of TB symptoms. Since TB symptoms are binary log, the binary distance or the jaccard distance are good candidates. The jaccard distance seems more appropriate given that the presence of a TB log is more important than the absence of TB symptoms.

However the tracking behavior also impacts how TB symptoms are reported by users: for example, frequent tracker might be more prone to report TB symptoms, while infrequent trackers might not bother opening the app even if they experience TB.
Inversely, symptoms (TB, bleeding or other symptoms) might triger the user to report them and use the app. 

We thus wanted to define a metric that would account for similarities in tracked symptoms and in tracking behavior so that we can differentiate between the absence of tracking and the absence of symptoms.


We define the metric as follow:

$ d = 1 - r*S_s - (1-r)*S_t $

Where $S_s$ is the symptom similarity metric and $S_t$ is the tracking similarity metric

### Symptom similarity metric : adapted Jaccard distance

The Jaccard distance ([Jaccard Index][https://en.wikipedia.org/wiki/Jaccard_index] - continuous case) is the most suited distance for the evaluating the similarity in symptoms reports between 2 cycles. Briefly, the Jaccard index reflects the ratio between the overlap (intersection) of days with symptoms and the union of all days with symptoms.

#### Smoothing the logs over time

Because of the time-resolution of this dataset (daily logs) and the relatively slow dynamic of the TB symptom (Breast tenderness rarely (dis)appears suddenly), it seemed relevant to allow for some fuzziness on the cycledays.
For example, if a user report TB on the first day of their period on one cycle and on the second day of their period on the next cycle, we might want to consider that these two cycles are not completely different.

We thus define the $S_s$ as the Jaccard Index between cycles with smoothed TB reports.

$ S_{s_{1,2}} = J(smoothed(C_1), smoothed(C_2)) $

The smoothing at cycleday $i$ is computed such as:
$ smoothed(C)_i = \frac{1}{4} C_{i-1} + \frac{1}{2} C_i + \frac{1}{4} C_{i+1} $


### Tracking similarity metric: binary distance

For comparing the tracking behavior, we use the [binary distance][https://en.wikipedia.org/wiki/Hamming_distance].

### Weights on the cycledays 

We also define a weight for each cycleday so that peri-menstrual days contribute to the distance more than days away from menstruation.

```{r cycle_clust_metric weights, fig.height=1, fig.width= 4}

ggplot(par$ww, aes(x = cycleday_m_D, y = w)) + 
  geom_vline(xintercept = 0, col = "gray90", size = 2)+
  geom_point() + geom_line()+
  scale_x_continuous(breaks = par$x.axis)

```



### Implementation

#### As an R function

The distance computations have been implemented with Rcpp in `Scripts/00_functions_distance.R`


```{r cycle_clust_metric examples , fig.height=3, fig.width= 7}

source("Scripts/00_functions_distance.R")


load(paste0(IO$output_data, "cycles.Rdata"), verbose = TRUE)
load(paste0(IO$tmp_data,"d_wide_imputed.Rdata"), verbose = TRUE)


j = c(1:12)
j = sample(1:nrow(d_wide),12)

d = reshape(d_wide[j,], idvar = "cycle_id_m", varying = list(2:ncol(d_wide)), new.row.names = 1:nrow(d_wide),
            direction = "long")
colnames(d) = c("cycle_id_m","cycleday_m_D","tender_breasts")
d$cycleday_m_D = d$cycleday_m_D - 19
d$user_id = cycles$user_id[match(d$cycle_id_m, cycles$cycle_id)]
d$cycle_nb_m = cycles$cycle_nb[match(d$cycle_id_m, cycles$cycle_id)]
d$cycle_id_m = as.character(d$cycle_id_m)

g_examples = ggplot_imputed_TB(d, col = "cycle_id_m")
#g_examples


distances = reshape_distance_matrix_to_long(TB_distance(M = d_wide[j,-1], r = par$r, w = par$w ))

g_distances = ggplot(distances, aes(x = i, y = j, col = dist)) + geom_point(size = 10) + xlab("") + ylab("") + scale_color_gradient(low = "lightblue",high = "tomato", na.value = "transparent")
#g_distances

grid.arrange(g_examples, g_distances, nrow = 1)


d_wide_sample = d_wide[j,]
save(d_wide_sample, file = paste0(IO$tmp_data, "d_wide_sample.Rdata"))
save(d, file = paste0(IO$tmp_data, "d_sample.Rdata"))


```

#### Within the CLARA function (cluster package)

Because our dataset is very large, we need to use an efficient clustering method.
The CLARA algorithm (for Clustering LARge Applications) is better suited to cluster the cycles.
In the existing package, the CLARA function only allows for the following distances: `euclidian`, `manhattan` and `jaccard`.
Consequently, we modified the C code from the CLARA function to implement the distance defined above.

The sources for the modified package can be found (here)(link to modified cluster package).

```{r cycle_clust_metric checking the clara implementation, fig.width=12}


source("Scripts/00_setup.R")
source("Scripts/00_functions_distance.R")

load(paste0(IO$tmp_data, "d_wide_sample.Rdata"), verbose =  TRUE)
load(paste0(IO$tmp_data, "d_sample.Rdata"), verbose =  TRUE)


distance_Rcpp = TB_distance(M = d_wide_sample[,-1], r = par$r, w = par$w)

clusters_clara = clara(d_wide_sample[,-1], k = 2, metric = "custom_jaccard", w = par$w, cjratio = par$r)

distance_clara = as.matrix(clusters_clara$diss)

all(round(distance_Rcpp,4) == round(distance_clara,4))

sum(abs(distance_Rcpp - distance_clara))/(nrow(distance_Rcpp) * (ncol(distance_Rcpp)))

distance_Rcpp = reshape_distance_matrix_to_long(distance_Rcpp)
distance_clara = reshape_distance_matrix_to_long(distance_clara)


g_distances_Rcpp = ggplot(distance_Rcpp, aes(x = i, y = j, col = dist)) + geom_point(size = 10) + xlab("") + ylab("") + scale_color_gradient(breaks = seq(0,1,by = 0.1),low = "lightblue",high = "tomato", na.value = "transparent") + guides(col = FALSE)

g_distances_clara = ggplot(distance_clara, aes(x = i, y = j, col = dist)) + geom_point(size = 10) + xlab("") + ylab("") + scale_color_gradient(breaks = seq(0,1,by = 0.1),low = "lightblue",high = "tomato", na.value = "transparent") + guides(col = FALSE)
#g_distances

g_examples = ggplot_imputed_TB(d, col = "cycle_id_m")


grid.arrange(g_examples, g_distances_Rcpp, g_distances_clara, nrow = 1)

plot(distance_Rcpp$dist, distance_clara$dist, xlim = c(0,1),ylim = c(0,1)); abline(a = 0, b = 1)

```


##### Instructions to modify the CLARA function in the Cluster package

- download the cluster package, unzip and place the folder `cluster` where you see fit.

- in RStudio: File > Open Project in New Session... ; Select the `cluster` folder (the one from step above)

- modify the files:

  * `clara.q` (R code calling the C function) [only need to change if function arguments are changed] ;

  * `clara.c` (the main clara function, implemented in C) ;

  * `clara.Rd` (documentation) ;

  * `cluster.h` (C and Fortran function declaration) [only need to change if function arguments are changed] ;

  * `init.c` (initialize the function ) [only need to change if function arguments are changed]
  
  
- When done, in RStudio : Build > Clean and Rebuild

- If there are errors, fix them ; if it builds properly, Yay!

- To test the package, restart a new session and load the `cluster` package ( by typing `library(cluster)`) and use clara to check if the changes have been properly implemented. (The chunk above is written for this test).




In `clara.c` the distance function is present in 3 places:

- 1 x inside the `dysta2` function ( ~ lines 400)

- 2 x inside the `selec` function ( ~ lines 700 and 750) [one if no missing data, one if missing data] 

![](../Figures Tables Media/Media/Clara distance.JPG)

















